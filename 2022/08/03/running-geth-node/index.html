<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  
  
  <title>Uniswap, Geth, SSH</title>
  <meta name="description" content="Behind major Ethereum applications, such as OpenSea for NFTs and dYdX for trading, there is usually a “blockchain developer platform” (e.g. Alchemy, QuickNode, Infura) that acts as an API layer to interact with any given blockchain network. For instance, to pull Uniswap on-chain price for WETH-USDC, I can get an API key from Alchemy and use Uniswap’s SDK (example below).">
  

  <link rel="stylesheet" href="/assets/main.css">
  <link rel="canonical" href="https://axucar.ca/2022/08/03/running-geth-node/">
  
  
  <link rel="alternate" type="application/rss+xml" title="Carlos Xu" href="https://axucar.ca/feed.xml">

  <script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>

<!-- SEO tags -->
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Uniswap, Geth, SSH | Carlos Xu</title>
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Uniswap, Geth, SSH" />
<meta name="author" content="Carlos Xu" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Behind major Ethereum applications, such as OpenSea for NFTs and dYdX for trading, there is usually a “blockchain developer platform” (e.g. Alchemy, QuickNode, Infura) that acts as an API layer to interact with any given blockchain network. For instance, to pull Uniswap on-chain price for WETH-USDC, I can get an API key from Alchemy and use Uniswap’s SDK (example below)." />
<meta property="og:description" content="Behind major Ethereum applications, such as OpenSea for NFTs and dYdX for trading, there is usually a “blockchain developer platform” (e.g. Alchemy, QuickNode, Infura) that acts as an API layer to interact with any given blockchain network. For instance, to pull Uniswap on-chain price for WETH-USDC, I can get an API key from Alchemy and use Uniswap’s SDK (example below)." />
<link rel="canonical" href="https://axucar.ca/2022/08/03/running-geth-node/" />
<meta property="og:url" content="https://axucar.ca/2022/08/03/running-geth-node/" />
<meta property="og:site_name" content="Carlos Xu" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-08-03T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Uniswap, Geth, SSH" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Carlos Xu"},"dateModified":"2022-08-03T00:00:00+00:00","datePublished":"2022-08-03T00:00:00+00:00","description":"Behind major Ethereum applications, such as OpenSea for NFTs and dYdX for trading, there is usually a “blockchain developer platform” (e.g. Alchemy, QuickNode, Infura) that acts as an API layer to interact with any given blockchain network. For instance, to pull Uniswap on-chain price for WETH-USDC, I can get an API key from Alchemy and use Uniswap’s SDK (example below).","headline":"Uniswap, Geth, SSH","mainEntityOfPage":{"@type":"WebPage","@id":"https://axucar.ca/2022/08/03/running-geth-node/"},"url":"https://axucar.ca/2022/08/03/running-geth-node/"}</script>
<!-- End Jekyll SEO tag -->


<!-- Google Analytics tracking ID -->



  
  <meta property="og:title" content="Uniswap, Geth, SSH">
  <meta property="og:site_name" content="Carlos Xu">
  <meta property="og:url" content="https://axucar.ca/2022/08/03/running-geth-node/">
  <meta property="og:description" content="Behind major Ethereum applications, such as OpenSea for NFTs and dYdX for trading, there is usually a “blockchain developer platform” (e.g. Alchemy, QuickNode, Infura) that acts as an API layer to interact with any given blockchain network. For instance, to pull Uniswap on-chain price for WETH-USDC, I can get an API key from Alchemy and use Uniswap’s SDK (example below).">
  
  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:site" content="jekyllrb">
  <meta name="twitter:title" content="Uniswap, Geth, SSH">
  <meta name="twitter:description" content="Behind major Ethereum applications, such as OpenSea for NFTs and dYdX for trading, there is usually a “blockchain developer platform” (e.g. Alchemy, QuickNode, Infura) that acts as an API layer to ...">
  
    <meta name="twitter:creator" content="jekyllrb">
  
  

  <link rel="dns-prefetch" href="https://fonts.gstatic.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bitter:ital,wght@0,400;0,700;1,400&amp;display=swap" rel="stylesheet">

  
  
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-N1HZQHWCY2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-N1HZQHWCY2');
    </script>
  


</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">Carlos Xu</a>

    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/posts/">Posts</a>
      
        
        <a class="page-link" href="/bookshelf/">Bookshelf</a>
      
    </nav>

  </div>

</header>


    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
      <h1 class="post-title" itemprop="name headline">Uniswap, Geth, SSH</h1>
    
    <p class="post-meta"><time datetime="2022-08-03T00:00:00+00:00" itemprop="datePublished">Aug 3, 2022</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <ul id="markdown-toc">
  <li><a href="#get-started-with-geth" id="markdown-toc-get-started-with-geth">Get started with Geth</a>    <ul>
      <li><a href="#syncing" id="markdown-toc-syncing">Syncing</a></li>
      <li><a href="#json-rpc-server" id="markdown-toc-json-rpc-server">JSON-RPC Server</a></li>
    </ul>
  </li>
  <li><a href="#uniswap-prices" id="markdown-toc-uniswap-prices">Uniswap Prices</a></li>
  <li><a href="#setting-up-ssh" id="markdown-toc-setting-up-ssh">Setting up SSH</a>    <ul>
      <li><a href="#ssh-tunneling-local-port-forwarding" id="markdown-toc-ssh-tunneling-local-port-forwarding">SSH Tunneling (Local Port Forwarding)</a></li>
    </ul>
  </li>
</ul>
<p>Behind major Ethereum applications, such as OpenSea for NFTs and dYdX for trading, there is usually a “blockchain developer platform” (e.g. Alchemy, QuickNode, Infura) that acts as an API layer to interact with any given blockchain network. For instance, to pull Uniswap on-chain price for WETH-USDC, I can get an API key from Alchemy and use Uniswap’s SDK (example <a href="#uniswap-on-chain-pricing">below</a>).</p>

<p>However, in the spirit of learning, I was curious how to run a local Ethereum node instead. I used a NUC (Intel  i7 9700, 32GB RAM, 2TB SSD, Ubuntu). In particular, the Go Ethereum (Geth) client seemed like the easiest one to get started with. Note that for the sake of client diversity for the Ethereum network, it is recommended to use other client implementations since Geth is by far the most popular at this point (for instance, OpenEthereum or Nethermind).</p>

<p>Since I was running dual boot with Windows with the storage split half-way, I first expanded the Ubuntu partition to make more room. In Ubuntu, a mounted drive that is in use can’t be expanded, so I boot from a live Ubuntu USB in trial mode, and used <code class="language-plaintext highlighter-rouge">gparted</code> which is pre-installed to do the disk resizing.</p>

<h2 id="get-started-with-geth">Get started with Geth</h2>

<p>I installed Geth using builtin-in <a href="https://geth.ethereum.org/docs/install-and-build/installing-geth#ubuntu-via-ppas">launchpad PPA</a>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>add-apt-repository <span class="nt">-y</span> ppa:ethereum/ethereum<span class="sb">`</span>
<span class="nb">sudo </span>apt-get update
<span class="nb">sudo </span>apt-get <span class="nb">install </span>ethereum
</code></pre></div></div>

<h3 id="syncing">Syncing</h3>
<p>To sync to the current state of the network, just run <code class="language-plaintext highlighter-rouge">geth</code> in the command line. By default, it will run a full node (using “snap” sync), which is what I did.</p>
<ul>
  <li>A full node stores all blocks since genesis, hence all state can be derived from it.</li>
  <li>Alternatively, one can try syncing a light node <code class="language-plaintext highlighter-rouge">geth --syncmode light</code>, which only stores header blocks (trust that majority are validating transactions using full nodes)</li>
  <li>An archival node <code class="language-plaintext highlighter-rouge">geth --syncmode full --gcmode archive --txlookuplimit=0 --cache.preimages</code> (which is a full node but also keeps a snapshot of all intermediate, historical states at every block). In contrast to an archival node, a full node only stores recent state for faster initial sync. Once fully synced, it will store all state moving forward as in archival nodes.</li>
</ul>

<p>At this point, the data directory <code class="language-plaintext highlighter-rouge">~/.ethereum</code> should be filling up quickly, since it is where all the historical data is saved. Restarting the node will simply pick up where it left off. Using the default settings, syncing mainnet took about 3 hours using up ~500GB of the SSD.</p>
<ul>
  <li>In a separate terminal to the one running <code class="language-plaintext highlighter-rouge">geth</code> , running <code class="language-plaintext highlighter-rouge">geth attach</code> opens a Javascript console (by default it attaches using IPC, found in <code class="language-plaintext highlighter-rouge">~/.ethereum/geth.ipc</code> which exists only when the geth node is running).</li>
  <li>To confirm when the syncing is done, you can compute <code class="language-plaintext highlighter-rouge">eth.syncing</code> within the Javascript console. If it returns <code class="language-plaintext highlighter-rouge">false</code>, syncing is finished.</li>
</ul>

<h3 id="json-rpc-server">JSON-RPC Server</h3>
<p>Geth supports the standard JSON-RPC API methods via multiple so-called transport protocols: IPC, HTTP, and Websocket. I only tried the first two. More details about Geth transport options <a href="https://geth.ethereum.org/docs/rpc/server">here</a>.</p>

<ul>
  <li>IPC provides unrestricted access to all method namespaces (eth, web3, net, etc.). Crucially, this only works when program is run locally on the same host as the Geth node
    <ul>
      <li>As a general rule, IPC is most secure because it is limited to interactions on the local machine and cannot be exposed to external traffic such as in HTTP</li>
      <li>The listening socket for the IPC server is placed in the data directory at <code class="language-plaintext highlighter-rouge">~/.ethereum/geth.ipc</code></li>
    </ul>
  </li>
  <li>HTTP (RPC) is the most widely used transport for interacting with Geth. By default, it only provides access to <code class="language-plaintext highlighter-rouge">eth, web3, net</code> method namespaces, because enabling other APIs like <code class="language-plaintext highlighter-rouge">personal</code> for account management over HTTP increases the attack surface for external traffic and is therefore not recommended.
    <ul>
      <li>To open an HTTP server, run <code class="language-plaintext highlighter-rouge">geth --http</code> . To check that the HTTP port is open, in a separate terminal run<code class="language-plaintext highlighter-rouge">curl http://localhost:8545</code> If nothing returned then HTTP connection is open, otherwise if the connection is refused then HTTP is not running.</li>
      <li>By default, the HTTP connection refers to <code class="language-plaintext highlighter-rouge">localhost</code> with listening port 8545. Only use default <code class="language-plaintext highlighter-rouge">http.addr=localhost</code> (otherwise opens access to external traffic)</li>
    </ul>
  </li>
</ul>

<h2 id="uniswap-prices">Uniswap Prices</h2>
<p>Now that we have an Ethereum node, we can try pulling the most up-to-date data on the blockchain, such as prices on Uniswap. I followed the <a href="https://docs.uniswap.org/sdk/2.0.0/guides/quick-start">Uniswap V2 SDK</a>.
My Uniswap boilerplate code below can also be found <a href="https://github.com/axucar/uniswap-boilerplate">on Github</a></p>

<p>Uniswap’s <code class="language-plaintext highlighter-rouge">fetchPairData</code> method allows us to specify an HTTP API using a URL, via the <code class="language-plaintext highlighter-rouge">ethers.js</code> module (see <a href="https://docs.ethers.io/v5/api/providers/jsonrpc-provider/">ethers’s JSON RPC documentation</a>). Below I tried 3 different methods (Alchemy API vs. IPC vs. HTTP), and noted a 10x speed difference between running on local node vs. using third-party HTTP API (Alchemy).</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">ChainId</span><span class="p">,</span> <span class="nx">Fetcher</span><span class="p">,</span> <span class="nx">WETH</span><span class="p">,</span> <span class="nx">Route</span><span class="p">,</span> <span class="nx">Trade</span><span class="p">,</span> <span class="nx">TokenAmount</span><span class="p">,</span> <span class="nx">TradeType</span><span class="p">,</span> <span class="nx">Token</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@uniswap/sdk</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">chainId</span> <span class="o">=</span> <span class="nx">ChainId</span><span class="p">.</span><span class="nx">MAINNET</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`The chainId of Mainnet is </span><span class="p">${</span><span class="nx">chainId</span><span class="p">}</span><span class="s2">.`</span><span class="p">)</span>
<span class="kd">const</span> <span class="nx">dai_tokenAddress</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">0x6B175474E89094C44Da98b954EedeAC495271d0F</span><span class="dl">'</span> <span class="c1">// must be checksummed</span>
<span class="kd">const</span> <span class="nx">usdc_tokenAddress</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48</span><span class="dl">'</span> <span class="c1">// must be checksummed</span>

<span class="k">import</span> <span class="nx">ethers</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">ethers</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">//METHOD 1: Alchemy, ~500-1000ms</span>
<span class="c1">// const url = 'https://eth-mainnet.g.alchemy.com/v2/&lt;YOUR-API-KEY&gt;';</span>
<span class="c1">// const customProvider = new ethers.providers.JsonRpcProvider(url);</span>

<span class="c1">//METHOD 2: IPC (LOCAL node machine only)</span>
<span class="c1">// const url = '/home/&lt;user&gt;/.ethereum/geth.ipc';</span>
<span class="c1">// const customProvider = new ethers.providers.IpcProvider(url);</span>

<span class="c1">//METHOD 3: HTTP, ~50-100ms</span>
<span class="kd">const</span> <span class="nx">url</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://localhost:8545</span><span class="dl">'</span><span class="p">;</span> 
<span class="kd">const</span> <span class="nx">customProvider</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">providers</span><span class="p">.</span><span class="nx">JsonRpcProvider</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">startTime</span> <span class="o">=</span> <span class="nx">performance</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>

<span class="kd">const</span> <span class="nx">init</span> <span class="o">=</span> <span class="k">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>	
	<span class="kd">const</span> <span class="nx">dai</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Token</span><span class="p">(</span><span class="nx">ChainId</span><span class="p">.</span><span class="nx">MAINNET</span><span class="p">,</span> <span class="nx">dai_tokenAddress</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="dl">'</span><span class="s1">DAI</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">Dai stablecoin</span><span class="dl">'</span><span class="p">);</span>	
	<span class="kd">const</span> <span class="nx">weth</span> <span class="o">=</span> <span class="nx">WETH</span><span class="p">[</span><span class="nx">dai</span><span class="p">.</span><span class="nx">chainId</span><span class="p">];</span>
	<span class="kd">const</span> <span class="nx">weth_dai_pair</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">Fetcher</span><span class="p">.</span><span class="nx">fetchPairData</span><span class="p">(</span><span class="nx">dai</span><span class="p">,</span> <span class="nx">WETH</span><span class="p">[</span><span class="nx">dai</span><span class="p">.</span><span class="nx">chainId</span><span class="p">],</span> <span class="nx">customProvider</span><span class="p">);</span> 		
	<span class="kd">const</span> <span class="nx">weth_dai_route</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Route</span><span class="p">([</span><span class="nx">weth_dai_pair</span><span class="p">],</span> <span class="nx">weth</span><span class="p">);</span> <span class="c1">//input is weth		</span>
	<span class="kd">const</span> <span class="nx">weth_dai_trade</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Trade</span><span class="p">(</span><span class="nx">weth_dai_route</span><span class="p">,</span> <span class="k">new</span> <span class="nx">TokenAmount</span><span class="p">(</span><span class="nx">weth</span><span class="p">,</span> <span class="nb">String</span><span class="p">(</span><span class="mf">0.1</span><span class="o">*</span><span class="mi">1</span><span class="nx">e18</span><span class="p">)),</span> <span class="nx">TradeType</span><span class="p">.</span><span class="nx">EXACT_INPUT</span><span class="p">);</span>	

	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Mid Price WETH --&gt; DAI:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">weth_dai_route</span><span class="p">.</span><span class="nx">midPrice</span><span class="p">.</span><span class="nx">toSignificant</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>	
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Execution Price WETH --&gt; DAI:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">weth_dai_trade</span><span class="p">.</span><span class="nx">executionPrice</span><span class="p">.</span><span class="nx">toSignificant</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Mid Price after trade WETH --&gt; DAI:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">weth_dai_trade</span><span class="p">.</span><span class="nx">nextMidPrice</span><span class="p">.</span><span class="nx">toSignificant</span><span class="p">(</span><span class="mi">6</span><span class="p">));</span>	
	<span class="kd">var</span> <span class="nx">endTime</span> <span class="o">=</span> <span class="nx">performance</span><span class="p">.</span><span class="nx">now</span><span class="p">();</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">-</span><span class="dl">"</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="mi">45</span><span class="p">));</span>
	<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`Call to Uniswap took </span><span class="p">${</span><span class="nx">endTime</span> <span class="o">-</span> <span class="nx">startTime</span><span class="p">}</span><span class="s2"> milliseconds`</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">init</span><span class="p">();</span>
</code></pre></div></div>

<p>To run the above, I installed Javascript via <code class="language-plaintext highlighter-rouge">nvm</code>. Then installed node.js version 16<code class="language-plaintext highlighter-rouge">nvm install 16</code> then <code class="language-plaintext highlighter-rouge">nvm use 16</code>. So ultimately <code class="language-plaintext highlighter-rouge">which node</code> for me points to <code class="language-plaintext highlighter-rouge">/home/&lt;username&gt;/.nvm/versions/node/v16.13.1/bin/node</code> . Also, the Uniswap script required <code class="language-plaintext highlighter-rouge">npm install @uniswap/sdk</code>, <code class="language-plaintext highlighter-rouge">npm install ethers</code>. Now, running <code class="language-plaintext highlighter-rouge">node test-uniswap-sdk.js</code> should give something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The chainId of Mainnet is 1.
Mid Price WETH --&gt; DAI: 1650.63
Execution Price WETH --&gt; DAI: 1645.65
Mid Price after trade WETH --&gt; DAI: 1650.56
---------------------------------------------
Call to Uniswap took 69.21298998594284 milliseconds
</code></pre></div></div>

<h2 id="setting-up-ssh">Setting up SSH</h2>
<p>I also have a laptop (running Ubuntu) from which I want to access the NUC’s files and ultimately the Geth node. In terms of accessing the NUC’s files, one can use <code class="language-plaintext highlighter-rouge">ssh</code> , see <a href="https://ubuntu.com/server/docs/service-openssh">OpenSSH on Ubuntu documentation</a> which walks through installation of the OpenSSH client and server application.</p>

<p>As first step, we need to get the IP address of the remote server (the NUC’s IP in this case).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ip addr show|grep <span class="s2">"inet "</span>
</code></pre></div></div>

<p>For instance, an IP address may have the form 192.168.x.xxx. On client (laptop) I would enter <code class="language-plaintext highlighter-rouge">ssh nuc_username@192.168.x.xxx</code>, where the username is that of the server (NUC). After being prompted for the remote host’s password, you can now access those remote files! You will notice terminal now says <code class="language-plaintext highlighter-rouge">nuc_username@server_name</code>.</p>

<p>To do SSH without password:</p>
<ul>
  <li>
    <p>generate ssh keys on my client (laptop) via <code class="language-plaintext highlighter-rouge">ssh-keygen -t rsa -b 4096</code> , which saves <code class="language-plaintext highlighter-rouge">~/.ssh/id_rsa.pub</code> (public key) and <code class="language-plaintext highlighter-rouge">~/.ssh/id_rsa</code> (private key) respectively. Then, we copy the public key to the remote host (in this case my NUC) via <code class="language-plaintext highlighter-rouge">ssh-copy-id nuc_username@192.168.x.xxx</code> (ie. nuc_username@remotehostIP)</p>
  </li>
  <li>
    <p>this will copy all the public keys in ~/.ssh/ into the remote host’s <code class="language-plaintext highlighter-rouge">~/.ssh/authorized_keys</code> file. Of course, this prompts for a password. When it’s done, no password will be required anymore. <code class="language-plaintext highlighter-rouge">exit</code> will log you out of the ssh’ed terminal</p>
  </li>
</ul>

<p>For other basic ssh commands on Ubuntu, see <a href="https://www.ssh.com/academy/ssh/command">this page</a>.</p>

<h3 id="ssh-tunneling-local-port-forwarding">SSH Tunneling (Local Port Forwarding)</h3>
<p>While the SSH has been setup, this still requires me to have my Uniswap script on the NUC and run against the Geth node once SSH’ed into the remote host. However, say I want to run the Uniswap boilerplate <a href="#uniswap-on-chain-pricing">above</a>, but using the local environment on my laptop (e.g. boilerplate script only exists on my laptop). Notice that the HTTP JSON-RPC provider parameter <code class="language-plaintext highlighter-rouge">const url = 'http://localhost:8545'</code> when running the Uniswap script on the NUC. I can tunnel some port on the laptop (say port 3333) to the default Geth port on my NUC (port 8545), and query the Geth node as if the node was running on my laptop.</p>

<p>Local forwarding allows forwarding a port from a client machine (my laptop) to the server machine (NUC). 
See this <a href="https://www.ssh.com/academy/ssh/tunneling/example">page</a> for an explanation.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-L</span> <span class="o">[</span>LOCAL_IP:] LOCAL_PORT:DESTINATION:DESTINATION_PORT USER@SSH_SERVER
</code></pre></div></div>

<p>In my case, running the following command on my laptop opens a connection to the remote host (NUC) and forwards the connection from <code class="language-plaintext highlighter-rouge">localhost:8545</code> on the NUC to <code class="language-plaintext highlighter-rouge">localhost:3333</code> on my laptop.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssh <span class="nt">-L</span> localhost:3333:localhost:8545 nuc_username@192.168.x.xxx<span class="sb">`</span>
</code></pre></div></div>

<p>Now, even though my laptop is not running Geth, I can connect to the NUC’s geth node via <code class="language-plaintext highlighter-rouge">localhost:3333</code></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//Now I can connect to the NUC's geth node from my laptop!</span>
<span class="kd">const</span> <span class="nx">url</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">http://localhost:3333</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">customProvider</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ethers</span><span class="p">.</span><span class="nx">providers</span><span class="p">.</span><span class="nx">JsonRpcProvider</span><span class="p">(</span><span class="nx">url</span><span class="p">);</span>
</code></pre></div></div>

  </div>

  

</article>

      </div>
    </main>

    <footer class="site-footer">

  <div class="wrapper">

    <p>
      <p style="font-size: 10px">Carlos Xu © <script>document.write(new Date().getFullYear());</script>


    </p>

  </div>

</footer>


  </body>

</html>
